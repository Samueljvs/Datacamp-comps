---
output:
  html_document:
    code_folding: hide
---

# Should your fund invest in Bitcoin?



```{r}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```


```{r pck-load, include = FALSE}
install.packages(c("PerformanceAnalytics", "quantmod", "tseries", "PortfolioAnalytics"))

library(tidyverse)
library(xts)
library(PerformanceAnalytics)
library(quantmod)
library(tseries)
library(PortfolioAnalytics)

# 
# bitcoin <- readr::read_csv('./data/bitcoin-usd.csv')
# sp500 <- readr::read_csv('./data/sp500.csv')
# monthly_data <- readr::read_csv('./data/monthly_data.csv')

monthly_xts <-  as.xts(read.zoo('./data/monthly_data.csv', sep = ",", header = TRUE))
bitcoin_xts <-  as.xts(read.zoo('./data/bitcoin-usd.csv', sep = ",", header = TRUE))
sp500_xts <-  as.xts(read.zoo('./data/sp500.csv', sep = ",", header = TRUE))

```

## Potfolio analysis

It's the expectation of gains that need to be balanced against the risk of losses. Reduce risks of suffering large loss - there are two tricks
 1) Carefully select diversified porfolios - one should avoid investing in one single investment and find good combinations of others - to reduce risk and increase returns
 2) Use back testing to test the portfolio analysis 
 
To conduct this you need to define portfolio Wights and Returns
* Weights tell you the percentage of total value invested into each asset
* returns measure relative increase over the period


```{r}

## plot data - check if anything weird is going on (e.g. missing vals)  - looks fine
##
  plot.zoo(bitcoin_xts)
  plot.zoo(sp500_xts)
  plot.zoo(monthly_xts[,1], main = "USD GOLD")
  plot.zoo(monthly_xts[,2], main = "US CPI")
  
## Show the value of sp500 and bitcoin value of close prices over time
  bit_sp500 <- Cl(bitcoin_xts) / Cl(sp500_xts)
  plot.zoo(bit_sp500, abline( h = 1), main = "Bitcoin / S&P500")
  
## aggregate to monthly to compare with gold and US CPI
##
  sp500_month <- to.period(sp500_xts, period = "months", indexAt = "firstof")
  bitcoin_month <- to.period(bitcoin_xts, period = "months", indexAt = "firstof")
  
```

How portfolio weight of each asset, despite bitcoin outstripping the value of SP 500 it's wise to invest in both that generate good return whilst mitigating risk loss. Reduce risk in holding both is good practice for diversifying risk. How good is the portfolio diversification, need to investigate how investment is spread across each asset.

How to set weights?

1) Betting on 1 Asset - speculative and likely to be inefficient
2) Equal weight - perfect diversification of assets in each risky asset (if assets are similar in terms of risk and reward)
3) weights proportional to the market value to the assets, over-weighting stocks of big firms an under-weighting stocks of small firms. 

However, to avoid extreme losses don't put all the eggs in one basket

By way of example, if we took close values at the September month 2014

```{r port-weights}
## take close price and weight them by their value
##
  in_vals <- first(merge(monthly_xts[,1], Cl(bitcoin_month), Cl(sp500_month)))
  weights <- in_vals / sum(in_vals)
  barplot(coredata(weights))
```

### Simple returns

Returns are the relative changes in value.
Weighted average reruns take into account, is the sumporduct of weights and corresponding returns.

```{r simple-returns}

fin_vals <- last(merge(monthly_xts[,1], Cl(bitcoin_month), Cl(sp500_month)))

returns_simple <- diff(rbind(in_vals, fin_vals))[2,] * coredata(weights)

returns_simple
```

### returns over time

As values of assets change over time you can either be a *passive investor and not trade any further* - this is called the buy and hold strategy. The second is to buy and trade at the close of each day(time period) that results in re balance of the portfolio, such that the portfolio is weighted correctly in the portfolio shares over time. 

```{r}
## over-time returns with PerformanceAnalytics
##
 returns <- Return.calculate(merge(monthly_xts[,1], Cl(bitcoin_month), Cl(sp500_month)))[(-1),]

plot.zoo(returns)

  weights_val <- c(0.4,0.1,0.5)
## Weights over time
##
 pf_ret <- Return.portfolio(returns, weights = weights_val,
                               rebalance = "months", verbose = TRUE)
```

## Portoflio returns

Portfolio performance is used make predictions about the past and future portfolio performance.
In general we consider performance across risk and rewards ( portfolio volatility, and mean return)

portfolio volatility is the de-meaned return - how much it vary s from the mean. high the volatility the higher the probability of a higher and lower returns across periods. Geometric mean reutnr accounts for the non-leaner offsets for losses and returns

The S&P 500 is generally considered the most important bench portfolio for investors in socks.
To interpret these numbers we need a benchmark to compare with - typically a risk free asset such as the TSY bill. Because there is no risk - the  expected return itself is called the risk free rate.

the difference between the risk-free-rate (asset) and the risky portfolio is called the excess Return of Risky Portfolio, and it tells us that how much additional return you can expect on the portfolio compared to the risk free rate.

capital allocation line - line between the risk free asset and portfolio - when you go beyond the portfolio return the investor takes leverage (borrows more capital to do so). The slope of this line is equal to the mean excess return of the portfolio / volatility fo the risk portfolio returns. the reward of the per unit o risk taken sharpe ratio.


```{r portfolio-performance}
##
plot.zoo(returns)
table.CalendarReturns(returns)
# Computing the mean monthly return

mean.geometric(returns)

# volatility
StdDev(returns)

## Sharpe ratio - the excess return /  standard deviation
Return.annualized(returns)
barplot(StdDev.annualized(returns))

# typically we look at the annualized performance of these stocks to see what investment looks like over a 1 year horizon. assuming risk-free rate of 0

table.AnnualizedReturns(returns)

```

### rolling estimation of returns
 
This gives us the K most recent values - this helps with business cycle and market direction. There are consistent period of calm and stress (bigger volatility). therefore current perormance is better estimate whn we give more weight ot recent observations than to the distant observations. This help accounts for differing business cycles - rolling estimation  

How do you pick your window length - large enough to reduce noise, but the trade off for making the window longer is that it's more smooth over the highs and lows over the data and the less informative it necewoam of the most recently observed performance. 


```{r window-performance}
## one year window
chart.RollingPerformance(R = returns, width = 12, FUN = "Return.annualized", legend.loc = "topleft", colorset = rich8equal, lwd = 2, main = "Rolling 12-Month Returns")

chart.RollingPerformance(R = returns, width = 12, FUN = "StdDev.annualized", legend.loc = "topleft", colorset = rich8equal, lwd = 2, main = "Rolling 12-Month Volatility")

chart.RollingPerformance(R = returns, width = 12, FUN = "SharpeRatio.annualized", Rf = 0, legend.loc = "topleft",colorset = rich8equal, lwd = 2, main = "Rolling 12-Month Sharpe Ratio")

```
## Measring risk to returns

### Non-normal returns and downside risk

Portfolio return has a normal distribution and the density function is bell shaped - and symmetric such gains and losses occur in equal amounts. however, this isn't typical of most stocks and have longer fatter tails at negative values. Non-normal return is skewed tot he left, More extreme negative values happening that is possible under a normal distribution. Therefore the SD is not enough of a measure for volatility.

There is a downside risk measure (through SD) is to remove the higher than average returns. This semi-deviation describes the average variability of the lower than average returns sqrt around the mean. 

There is other measures such as the value at risk and expected shortfall (at 5%),
To explain - the value at risk quantifies the risk of the 5% most extreme losses - 5% value at risk is are returns that are so extremely negative,  there is a 5% change of observing a return that is even more negative. Then compute the value of the those 5% most negative returns - thus, the 5% expected shortfall.

There is also reports of skewness and kurtosis (symmetry and tail fatness). Left-skewed means that more negative values occurs more often than large positive returns (long left tail). fat tails are a cause of non-normality, which means fatter-tails larger extreme values that occur. 



```{r}

## subset to look at the latest year of daily bitcoin  & S&P 500 returns
##
  returns_lastyr <-  Return.calculate(last(Cl(bitcoin_xts), n = 365))[-c(1),]
  returns_lastyr_sp <-  Return.calculate(last(Cl(sp500_xts), n = 365))[-c(1),]
  names(returns_lastyr) <- "Bitcoin"
  names(returns_lastyr_sp) <- "S&P 500"
  
  chart.Histogram(returns_lastyr, methods = c("add.density", "add.normal"))
  chart.Histogram(returns_lastyr_sp, methods = c("add.density", "add.normal"))
  
  ##  NOTE: Can also calculate on montly periods
  ##
  skewness(returns_lastyr)
  kurtosis(returns_lastyr)
  
  skewness(returns_lastyr_sp)
  kurtosis(returns_lastyr_sp)
  
  ## can also calculate the SemiDeviation, value-at-risk, and the expected short fall to evaluated the risk of returns.
  ##
      SemiDeviation(returns)
      VaR(returns, p = 0.05)
      ES(returns, p = 0.05)
## more compactly put below
##
table.DownsideRisk(returns)

```

These are all measures that describe risk over a period, but don't describe the worst-case of buying at peaks and selling at a rough. However, we can quantify draw downs - that is the worst case scenario for each stock

```{r}
table.Drawdowns(returns)
chart.Drawdown(returns)

```

## how to optimize future portfolio returns

there are typically three types of drivers for a portfolio's performance: (i) the individual performance of the assets in terms of risk and return, (ii) the portfolio weight of each of the assets, (iii) the correlation between the asset returns

### weights

```{r}
# choose between two equities we cna find the optimal weight ratio thorugh sharpe

bit_returns <- returns[,2]
sp_returns <- returns[,3]
grid <- seq(from = 0, to = 1, by = 0.01)

# Initialize an empty vector for Sharpe ratios
vsharpe <- rep(NA, times = length(grid))

# Create a for loop to calculate Sharpe ratios
for(i in 1:length(grid)) {
    weight <- grid[i]
    preturns <- weight * bit_returns + (1 - weight) * sp_returns
    vsharpe[i] <- SharpeRatio.annualized(preturns)
}

# Plot weights and Sharpe ratio
plot.zoo(grid, vsharpe, xlab = "Weights", ylab= "Ann. Sharpe ratio")
abline(v = grid[vsharpe == max(vsharpe)], lty = 3)

```


### correlations

We can also visualise the correlation between differing stocks. If there are more correlated this typically increases variance as when one suffers loss, it is likely so will the other. thus increasing the risks. These are drivers with he case of two assets in the portfolio. 
```{r}

## note this is all monthly  - can break this down to daily
## correlation
cor(bit_returns, sp_returns)


## scatter plot
chart.Scatter(bit_returns, sp_returns, xlab = "bitcoin returns", ylab = "S&P 500 returns", main = "equity returns")

chart.Correlation(merge(bit_returns,sp_returns))


## rolling estimates 6 month windows
chart.RollingCorrelation(bit_returns, sp_returns, width = 6)
```
 
We can extend this across all the assets - bicoin, gold, SP500.

```{r n-assets }

## get vector of mean returns across all assets to plot expectured return vs their risk (variance)

means <- apply(returns,2, "mean")
sds <- apply(returns,2, "mean")

plot.zoo(sds, means)
text(sds, means, labels = colnames(returns), cex = 0.7)
abline(h = 0, lty = 3)
```



### Who did it?

Portfolio analysis of each assets risk contributions

```{r}
## get conribtiuon for eacha ssets risk
vol_budget <- StdDev(returns, portfolio_method = "component", weights = weights_val)

weights_percrisk <- cbind(weights_val, vol_budget$pct_contrib_StdDev)

colnames(weights_percrisk) <- c("weights", "perc vol contrib")
print(weights_percrisk)
plot(weights_percrisk)
```

## Modern portfolio theory of Harry Markowitz

You can optimize your portfolio performance by setting targets and constraints to get you either highest return or lowest variability of some combinations that allows for higher return for lowest variability. by setting weight constrains it sops your portfolio form being completely dominated by just a few assets.

```{r}
# Create a vector of row means
ew_preturns <- rowMeans(returns)

# Cast the numeric vector back to an xts object
ew_preturns <- xts(ew_preturns, order.by = time(returns))

# Plot ew_preturns
plot.zoo(ew_preturns)

opt <- portfolio.optim(returns)

# Create pf_weights
pf_weights <- opt$pw

# Assign asset names
names(pf_weights) <- colnames(returns)

# Select optimum weights opt_weights
opt_weights <- pf_weights[pf_weights >= 0.01]

# Bar plot of opt_weights
barplot(opt_weights)

# Print expected portfolio return and volatility
opt$pm
opt$ps

# Create portfolio with target return of average returns 
pf_mean <- portfolio.optim(returns, pm = mean(returns))

# Create portfolio with target return 10% greater than average returns
pf_10plus <- portfolio.optim(returns, pm = 1.1 * mean(returns))


# Print the standard deviations of both portfolios
pf_mean$ps
pf_mean$ps

# Calculate the proportion increase in standard deviation
(pf_10plus$ps - pf_mean$ps) / (pf_mean$ps)

```

depending on the return targets you set, you find the optminal weights in your portfolio give you the lowest portfolio variability. The higher the return target, means higher variability. Mapping out all the return optimization you can obtains the efficient frontier. The portfolio that starts in called the minimum variance portfolio and it's the one where the return is sufficiently higher than the risk free rate. It is he portfolio that solves the problem of minimize variance without and constraint on expected returns.

You can evaluate each portfolio on the efficient frontier's sharpe ratio - you can a find a line that is tangent to the portfolio frontier - this is called the tangency portfolio - this portfolio is the one that has the highest sharpe ratio meaning that it is the highest return on the portfolio per unit of porfolio risk (variability). 


### split sample analysis

Because of estimation error through  mean estiamtion and variance estimation there is estimation error in the optimization weights.
However we can use split sample analysis to evaluate in an object way what the future performance of an optimized portfolio performance could be.

```{r}
## split retunrs data into two

# Create returns_estim 
returns_estim <- window(returns, start = "2014-09-01", end = "2017-12-01")

# Create returns_eval
returns_eval  <- window(returns, start = "2018-01-01", end  = "2021-11-01")

# Create portfolio with estimation sample 
pf_estim <- portfolio.optim(returns_estim)

# Create portfolio with evaluation sample
pf_eval <- portfolio.optim(returns_eval)

plot.zoo(pf_estim$pw, pf_eval$pw)
abline(a = 0, b = 1, lty = 3)


## let's have a look at how well the portfolio might have done!
# Create returns_pf_estim
returns_pf_estim <- Return.portfolio(returns_estim, pf_estim$pw, rebalance_on = "months")

# Create returns_pf_eval
returns_pf_eval <- Return.portfolio(returns_eval, pf_estim$pw, rebalance_on = "months")

# Print a table for your estimation portfolio
table.AnnualizedReturns(returns_pf_estim)

# Print a table for your evaluation portfolio
 table.AnnualizedReturns(returns_pf_eval)

```


### Better Optimizations an portfolio specifications - 

note the aim of this portfolio is one where we want to minimize portfolio volatility
So let's dive into the optimization process with the package PortfolioAnalytics to find the optimal portfolio weights across the 3 assets, gold, S&P 500 and Bitcoin.



Firstly, we want to define a benchmark for a accurately measuring the relative performance of our portfolio.
The benchmark will be without the bitcoin and then check to see how performance improves with bitcoin - we can also construct an equal weight benchmark of the 3 assets to invest in.

We will also start with a base portfolio specification and then hypothesis ways to improve the risk adjusted portfolio by confining constraints, objectives and possibly moment estimates.

The base portfolio specification is to minimize portfolio standard deviation subject to full investment and long only constraints. 

We will run re balancing to see how it performs historically.

```{r}
## construct the benchmark base
##
returns_bench <- returns[]

## equal weight vector
equal_weights <- rep(1 / ncol(returns_bench), ncol(returns_bench))

# Compute the benchmark returns
r_benchmark <- Return.portfolio(R = returns_bench, weights = equal_weights, rebalance_on = "months")
colnames(r_benchmark) <- "benchmark"

# Plot the benchmark returns

plot(r_benchmark)

```


```{r optomize}

## to compare against the benchmark let's create the an optimized portfolio

# Create the portfolio specification
port_spec <- portfolio.spec(colnames(returns))
# Add a full investment constraint such that the weights sum to 1
port_spec <- add.constraint(portfolio = port_spec, type = "weight_sum")
# Add a long only constraint such that the weight of an asset is between 0 and 1
port_spec <- add.constraint(portfolio = port_spec, type = "long_only")
# Add an objective to minimize portfolio standard deviation
port_spec <- add.objective(portfolio = port_spec, type = "risk", name = "StdDev")

# port_spec <- add.objective(portfolio = port_spec, type = "return", name = "mean")

## print portolfio
print(port_spec)

# Solve the optimization problem for one period
#opt <- optimize.portfolio(returns, portfolio = port_spec, optimize_method = "random", risk_aversion = 10)


## solve with re balancing: note: 12 months per year * 5 years  = 60 period - can extend to 86 months
opt <- optimize.portfolio.rebalancing(returns, portfolio = port_spec, optimize_method = "random", rebalance_on = "quarters", training_period = 60, rolling_window = 60 )
print(opt)

## now with the optimal weights extract and pass through portfolio return function

## let's analyse some results
##
  extractWeights(opt)
  chart.Weights(opt)
  extractObjectiveMeasures(opt)
  
  ## compute the re balancing historical returns
  rr <- Return.portfolio(returns, weights = extractWeights(opt))
  colnames(rr) <- "base"
  charts.PerformanceSummary(rr)
  
```

### perhpas we add a concentration risk

add a box constraint to add a lower and upper bound to weights - such that the weight of assets 

```{r box-constraint}

## Copy the specification
box_con_spec <- port_spec

box_con_spec <- add.constraint(portfolio = box_con_spec, type = "box",
                               min = 0.05, max = 0.6,
                               indexnum = 2)

box_opt <- optimize.portfolio.rebalancing(returns, portfolio = box_con_spec, optimize_method = "random", 
                                          rebalance_on = "quarters", training_period = 60, 
                                          rolling_window = 60)
print(box_opt)
chart.Weights(box_opt)

  rb  <- Return.portfolio(returns, weights = extractWeights(box_opt))
  colnames(rb) <- "Box constraints"
  
  charts.PerformanceSummary(rb)
```


Let's add a risk budget objective to set a minimum and maximum percent contribution to risk for each asset

```{r}

port_spec <- add.constraint(portfolio = port_spec, 
                           type = "risk_budget", 
                           name = "StdDev", 
                           min_prisk = 0.05, 
                           max_prisk = 0.4)


# Run the optimization
opt_rebal_rb <- optimize.portfolio.rebalancing(R = returns, 
                                               portfolio = port_spec, 
                                               optimize_method = "random",
                                               trace = TRUE,
                                               rebalance_on = "quarters", 
                                               training_period = 60,
                                               rolling_window = 60)
# Chart the weights
chart.Weights(opt_rebal_rb)

# Chart the percentage contribution to risk
#chart.RiskBudget(opt_rebal_rb, match.col = "StdDev", risk.type = "percentage")

# Compute the portfolio returns
returns_rb <- Return.portfolio(R = returns, weights = extractWeights(opt_rebal_rb))

colnames(returns_rb) <- "risk_budget"

ret <- cbind(r_benchmark, rr, rb, returns_rb)

## check annualized performance
##
  table.AnnualizedReturns(ret)

## Chart the performance summary
charts.PerformanceSummary(R = ret)
```

